import numpy as np
import fnmatch
import os
import sys
import scipy.io as sio
from tqdm import tqdm

if __name__ == "__main__": 
    """Some of the dataset files generated by main.py are not size of 64. Bring altogether to make it suitable for training.
    """
    # run e.g. python3 main2.py 0 (test data)
    args = sys.argv[1:]
    train_or_test = int(args[0]) # 0: test, 1: train
    train = bool(train_or_test)
    #test = bool(train_or_test)
    if train:
        train_matrices_names_list = fnmatch.filter(os.listdir('/raid/home/hyovin.kwak/PIE-NET_Dataset_Preparation/mat_after_main1_ohneKreis_ohneAmbg/'), '*.mat')
        #tunnel_slice_mat_list = ["tunnel/train/slice_m148_r45.mat", "tunnel/train/slice_m939_r70.mat"]
        #train_matrices_names_list = tunnel_slice_mat_list + train_matrices_names_list
        train_matrices_names_list_num = len(train_matrices_names_list)
        prefix = ""
    else:
        # slice_m148_r45 is in train
        # tunnel/train/slice_m939_r70.mat in train
        # slice_m128_r45 is in test
        #tunnel_slice_mat_list = ["tunnel/test/slice_m128_r45.mat", "tunnel/test/slice_m954_r70.mat"]
        #tunnel_slice_mat_list = ["tunnel/test/slice_m128_r45.mat"]
        #tunnel_slice_mat_list = ["tunnel/train/slice_m148_r45.mat"]
        #tunnel_slice_mat_list = ["tunnel/train/slice_m939_r70.mat"]
        tunnel_slice_mat_list = ["tunnel/test/slice_m954_r70.mat"]
        train_matrices_names_list = tunnel_slice_mat_list*64
        train_matrices_names_list_num = 64
        prefix = "test_"

    batch_count = 0
    file_count = 0
    data = {'Training_data': np.zeros((64, 1), dtype = object)}
    for k in tqdm(range(train_matrices_names_list_num)):
        loadpath = "/raid/home/hyovin.kwak/PIE-NET_Dataset_Preparation/mat_after_main1_ohneKreis_ohneAmbg/" + train_matrices_names_list[k]
        ref_mat = sio.loadmat(loadpath)['Training_data']
        end_count = sio.loadmat(loadpath)['batch_count'][0, 0]
        #if train_matrices_names_list[k][-7:] == "end.mat": 
        #    end_count = end_count - 1
        #elif train_matrices_names_list[k][-7:] != "end.mat": end_count += 1
        i = 0
        while i < end_count:
            save_this = False
            down_sample_point = ref_mat[i, 0]['down_sample_point'][0, 0]
            edge_points_residual_vector = ref_mat[i, 0]['edge_points_residual_vector'][0, 0]
            corner_points_residual_vector = ref_mat[i, 0]['corner_points_residual_vector'][0, 0]
        
            # initialize memory arrays
            edge_points_label = ref_mat[i, 0]['edge_points_label'][0, 0][0, :][:, np.newaxis]
            corner_points_label = ref_mat[i, 0]['corner_points_label'][0, 0][0, :][:, np.newaxis]
            open_gt_pair_idx = ref_mat[i, 0]['open_gt_pair_idx'][0, 0]
            open_gt_valid_mask = ref_mat[i, 0]['open_gt_valid_mask'][0, 0]
            open_gt_256_sn_idx = ref_mat[i, 0]['open_gt_256_sn_idx'][0, 0]
            open_gt_type = ref_mat[i, 0]['open_gt_type'][0, 0] # Note: BSpline and Lines, so two label types: 1, 2
            open_type_onehot = ref_mat[i, 0]['open_type_onehot'][0, 0][:, 0:3]
            open_gt_res = ref_mat[i, 0]['open_gt_res'][0, 0]
            open_gt_sample_points = ref_mat[i, 0]['open_gt_sample_points'][0, 0]
            open_gt_mask = ref_mat[i, 0]['open_gt_mask'][0, 0]
            closed_gt_256_sn_idx = ref_mat[i, 0]['closed_gt_256_sn_idx'][0, 0]
            closed_gt_mask = ref_mat[i, 0]['closed_gt_mask'][0, 0]
            closed_gt_type = ref_mat[i, 0]['closed_gt_type'][0, 0]
            closed_gt_res = ref_mat[i, 0]['closed_gt_res'][0, 0]
            closed_gt_sample_points = ref_mat[i, 0]['closed_gt_sample_points'][0, 0]
            closed_gt_valid_mask = ref_mat[i, 0]['closed_gt_valid_mask'][0, 0]
            closed_gt_pair_idx = ref_mat[i, 0]['closed_gt_pair_idx'][0, 0]
            tp = np.dtype([
                ('down_sample_point', 'O'),
                ('edge_points_label', 'O'),
                ('edge_points_residual_vector', 'O'),
                ('corner_points_label', 'O'),
                ('corner_points_residual_vector', 'O'),
                ('open_gt_pair_idx', 'O'),
                ('closed_gt_pair_idx', 'O'),
                ('open_gt_valid_mask', 'O'),
                ('closed_gt_valid_mask', 'O'),
                ('open_gt_256_sn_idx', 'O'),
                ('closed_gt_256_sn_idx', 'O'),
                ('open_gt_type','O'),
                ('closed_gt_type','O'),
                ('open_type_onehot','O'),
                ('open_gt_res', 'O'),
                ('closed_gt_res', 'O'),
                ('open_gt_sample_points', 'O'),
                ('closed_gt_sample_points', 'O'), 
                ('open_gt_mask', 'O'),
                ('closed_gt_mask', 'O')
                ])
            
            def close_visualization_yes(vis):
                global save_this
                save_this = True
                print("save_this: ", save_this)
                vis.close()
            def close_visualization_no(vis):
                global save_this
                save_this = False
                print("save_this: ", save_this)
                vis.close()
            print("file_count: ", file_count, "// batch_count: ", batch_count)
            color_array = np.zeros_like(down_sample_point)
            color_array[edge_points_label, ...] = [0.0, 0.70, 0.0]
            color_array[corner_points_label, ...] = [0.99, 0.99, 0.0]
            
            point_cloud = open3d.geometry.PointCloud()
            point_cloud.points = open3d.utility.Vector3dVector(down_sample_point)
            point_cloud.colors = open3d.utility.Vector3dVector(color_array)

            vis = open3d.visualization.VisualizerWithKeyCallback()
            vis.create_window()
            vis.register_key_callback(89, close_visualization_yes) # Q
            vis.register_key_callback(78, close_visualization_no) # Q
            vis.add_geometry(point_cloud)
            vis.run()

            if save_this:
                data['Training_data'][batch_count, 0] = np.zeros((1, 1), dtype = tp)
                for tp_name in tp.names: 
                    save_this = locals()[tp_name]
                    data['Training_data'][batch_count, 0][tp_name][0, 0] = save_this


                if batch_count == 63:
                    # save mat
                    file_ = prefix+str(file_count)+".mat"
                    sio.savemat(file_, data)

                    # renew batch_count
                    batch_count = 0
                    file_count = file_count + 1
                    data = {'Training_data': np.zeros((64, 1), dtype = object)}
                else:
                    batch_count = batch_count + 1

            i = i + 1
